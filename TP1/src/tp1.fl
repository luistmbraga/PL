%{
/* Declaracoes C diversas */
#define _GNU_SOURCE
#include <comentarios.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

long profundidade = 0;
int contador = 0;
Nivel com = NULL;
FILE *fptr;

void printTimestamp(); 
void endComment();
void printNTimes(int times, char print); 
void printFieldStringPreDef(char* string);  
void printFieldString(char* field, char* yytext, int ultimo);
void printFieldNum(char* field, long num, int ultimo); 
%}
%option stack
/* Abreviaturas de ER */

space		[\ \t \n]
decimal 	[0-9]
acentos 	\xc3[\x80-\xbf]
alpha 		[a-zA-Z]
letra 		{alpha}|{acentos}
palavra		{letra}+

comList		\<ol\ +class\ *=\ *\"comments__list\"
com		\<li\ +class\ *=\ *\"comment\"
id		data\-comment\-id=\"
time		\<time
datetime 	datetime\ *=\ *\"
nome		\<h5\ *class=\"comment__author\"\ *\>{space}*\<a[^\>]+\>
commentText \<div\ *class=\"comment__content\"\>{space}*\<p\>
texto		(\x21-\x7e|{acentos}|\x(fffd))+

%x COMLIST COM ID TIME DATETIME NAME COMMENTEXT

%%
{comList}			{yy_push_state(COMLIST);}

<COMLIST>{
{com}				{
						if(profundidade > 0){ addComment(com); com = addNivelToComment(com);}
						printFieldStringPreDef("{\n");
						printTimestamp();
						printFieldStringPreDef("\"likes\": 0,\n");
						yy_push_state(COM);
					}
\<\/ol\>			{
						if(profundidade > 0) printFieldStringPreDef("],\n");
						--profundidade;
						yy_pop_state(); 
					}
}

<COM>{ 
{comList}							{
										printFieldStringPreDef("\"hasReplies\": true,\n");
										printFieldStringPreDef("\"replies\": [\n");
										++profundidade;
										if(profundidade == 1) com = createNivel(com);
										yy_push_state(COMLIST); 
									}
{id}								{yy_push_state(ID);}
{time}								{yy_push_state(TIME);}
\<\/li\>/{space}*\<\/ol\>			{
										endComment();
										printFieldStringPreDef("}\n");
									}
\<\/li\>/{space}*\<li				{
										endComment();
										printFieldStringPreDef("},\n");
									}
{nome}								{yy_push_state(NAME);}
{commentText}						{
										printNTimes(profundidade, '\t'); 
										fprintf(fptr, "\"commentText\": \""); 
										yy_push_state(COMMENTEXT);
									}
}

<ID>{
({alpha}|{decimal}|\-)+ 	{printFieldString("id", yytext, 0);}
\"							{yy_pop_state();}
}

<TIME>{
{datetime}					{yy_push_state(DATETIME);}
\>							{yy_pop_state();}
}

<DATETIME>{
({decimal}|[\-\:\.T])+		{printFieldString("date", yytext, 0);}
\"							{yy_pop_state();}
}

<NAME>{
.+/\<\/a\>					{printFieldString("user", yytext, 0);}
\<\/a\>						{yy_pop_state();}
}

<COMMENTEXT>{
\<\/p\>							{fprintf(fptr, "\",\n"); yy_pop_state();}
\"								{fprintf(fptr, "\\\"");}
.								{fprintf(fptr, yytext);}
\n 								{fprintf(fptr, "\\n");}
}

<*>.|\n				{}
%%

int yywrap()
{ return(1); }

void help(){

	printf("\n");
	printf("*--------------------------------HELP-----------------------------*\n");
	printf("*                         	                                  	  *\n");
	printf("*    Utilização:                                                  *\n");
	printf("*                 1- make                                         *\n");
	printf("*                 2- ./program [nome do ficheiro a processar]     *\n");
	printf("*                                                                 *\n");
	printf("*--------------------------------HELP-----------------------------*\n");

}

void endComment(){
	long nReplies = numberOfReplies(com);

	if(nReplies > 0) {
		printFieldNum("numberOfReplies", nReplies, 1);
	}
	else{
		// para não imprimir como string
		printFieldStringPreDef("\"hasReplies\": false,\n");
		printFieldNum("numberOfReplies", numberOfReplies(com), 0);
		printFieldStringPreDef("\"replies\": []\n");
	}

	if(profundidade > 0) com = getAnt(com);
	else com = NULL;

	yy_pop_state();
}

void printNTimes(int times, char print){
	for(int i = -1; i < times; i++)
		fprintf(fptr, "%c", print);
}

void printFieldStringPreDef(char* string){
	printNTimes(profundidade, '\t');
	fprintf(fptr, "%s", string);
}

void printFieldString(char* field, char* yytext, int ultimo){
	printNTimes(profundidade, '\t');
	if(ultimo == 1)	fprintf(fptr, "\"%s\": \"%s\"\n", field, yytext);
	else fprintf(fptr, "\"%s\": \"%s\",\n", field, yytext);
}

void printFieldNum(char* field, long num, int ultimo){
	printNTimes(profundidade, '\t');
	if (ultimo == 1) fprintf(fptr, "\"%s\": %ld\n", field, num);
	else fprintf(fptr, "\"%s\": %ld,\n", field, num);
}

void printTimestamp(){
	time_t t = time(NULL);
	printFieldNum("timestamp", t, 0);	
}

int main(int argc, char* argv[]){ 
	
	if(argc < 2){
		help();
		return 0;
	}
	
	if(access(argv[1], F_OK) != -1){

		if(access(argv[1], R_OK) != -1){

			// abrir o ficheiro temporário para escrever
			fptr = fopen("TEMP.json", "w");

			// escrever nome da collection
			fprintf(fptr, "{\"commentThread\": [\n");
			
			// abrir o ficheiro a ler
			yyin = fopen(argv[1], "r");

			// inicializar a leitura
			yylex();
	
			// fechar a collection
			fprintf(fptr, "]}\n");

			fclose(yyin);
			fclose(fptr);

			int len = strlen(argv[1]);

			// definir nome do ficheiro final
			char CP1252toUTF8[45+len];
			char nome[len+3];
			strcpy(nome, argv[1]);
			nome[len-5] = '\0';
			strcat(nome, "JSON.json");
			
			// Como o ficheiro de input (yyin) tem o encoding CP1252 tem se passar para UTF8
			sprintf(CP1252toUTF8, "iconv -f cp1252 -t utf8 TEMP.json > \"%s\"", nome); 
			system(CP1252toUTF8);
			system("rm TEMP.json");

		}
		else{
			printf("Não possui permissão de leitura sobre o ficheiro fornecido!\n");
		}
	}
	else{
		printf("O ficheiro dado como argumento não existe !\n");
	}

	return 0;
}
