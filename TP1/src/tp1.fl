%{
/* Declaracoes C diversas */
#define _GNU_SOURCE
#include <comentarios.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

long profundidade = 0;
int contador = 0;
Nivel com = NULL;

void printTimestamp(); 
void endComment();
void printNTimes(int times, char print); 
void printFieldStringPreDef(char* string);  
void printFieldString(char* field, char* yytext, int ultimo);
void printFieldNum(char* field, long num, int ultimo); 
%}
%option stack
/* Abreviaturas de ER */

space		[\ \t \n]
decimal 	[0-9]
acentos 	\xc3[\x80-\xbf]
alpha 		[a-zA-Z]
letra 		{alpha}|{acentos}
palavra		{letra}+

comList		\<ol\ +class\ *=\ *\"comments__list\"
com		\<li\ +class\ *=\ *\"comment\"
id		data\-comment\-id=\"
time		\<time
datetime 	datetime\ *=\ *\"
nome		\<h5\ *class=\"comment__author\"\ *\>{space}*\<a[^\>]+\>
commentText \<div\ *class=\"comment__content\"\>{space}*\<p\>
texto		([a-zA-Z]|[\n\t\ ]|[!\",�\.]|[\xc3[\x80-\xbf]])+
%x COMLIST COM ID TIME DATETIME NAME COMMENTEXT

%%
{comList}			{yy_push_state(COMLIST);}

<COMLIST>{
{com}				{
							if(profundidade > 0){ addComment(com); com = addNivelToComment(com);}
						printFieldStringPreDef("{\n");
						printTimestamp();
						printFieldStringPreDef("\"likes\": 0,\n");
						yy_push_state(COM);
					}
\<\/ol\>			{
							if(profundidade > 0) printFieldStringPreDef("],\n");
						--profundidade;
						yy_pop_state(); 
					}
}

<COM>{
{comList}			{
						printFieldStringPreDef("\"hasReplies\": TRUE,\n");
						printFieldStringPreDef("\"replies\": [\n");
						++profundidade;
							if(profundidade == 1) com = createNivel(com);
						yy_push_state(COMLIST); 
					}
{id}				{yy_push_state(ID);}
{time}				{yy_push_state(TIME);}
\<\/li\>/{space}*\<\/ol\>			{
										endComment();
										printFieldStringPreDef("}\n");
									}
\<\/li\>/{space}*\<li				{
										endComment();
										printFieldStringPreDef("},\n");
									}
{nome}								{yy_push_state(NAME);}
{commentText}						{yy_push_state(COMMENTEXT);}
}

<ID>{
({alpha}|{decimal}|\-)+ 	{printFieldString("id", yytext, 0);}
\"							{yy_pop_state();}
}

<TIME>{
{datetime}		{
								yy_push_state(DATETIME);
							}
\>							{yy_pop_state();}
}

<DATETIME>{
({decimal}|[\-\:\.T])+		{
								printFieldString("date", yytext, 0);
							}
\"							{yy_pop_state();}
}

<NAME>{
.+/\<\/a\>					{printFieldString("user", yytext, 0);}
\<\/a\>						{yy_pop_state();}
}

<COMMENTEXT>{
{texto}/\<\/p\>					{printFieldString("commentText", yytext, 0);}
\<\/p\>							{yy_pop_state();}
}

<*>.|\n				{}
%%

int yywrap()
{ return(1); }

void help(){

	printf("\n");
	printf("*--------------------------------HELP-----------------------------*\n");
	printf("*                         	                                  	  *\n");
	printf("*    Utilização:                                                  *\n");
	printf("*                 1- make                                         *\n");
	printf("*                 2- ./program [nome do ficheiro a processar]     *\n");
	printf("*                                                                 *\n");
	printf("*--------------------------------HELP-----------------------------*\n");

}

void endComment(){
	long nReplies = numberOfReplies(com);

	if(nReplies > 0) {
		printFieldNum("numberOfReplies", nReplies, 1);
	}
	else{
		printFieldString("hasReplies", "FALSE", 0);
		printFieldNum("numberOfReplies", numberOfReplies(com), 0);
		printFieldString("replies", "[]", 1);
	}

	if(profundidade > 0) com = getAnt(com);
	else com = NULL;

	yy_pop_state();
}

void printNTimes(int times, char print){
	for(int i = -1; i < times; i++)
		printf("%c", print);
}

void printFieldStringPreDef(char* string){
	printNTimes(profundidade, '\t');
	printf("%s", string);
}

void printFieldString(char* field, char* yytext, int ultimo){
	char string[yyleng+100];
	if(ultimo == 1)	sprintf(string, "\"%s\": \"%s\"\n", field, yytext);
	else sprintf(string, "\"%s\": \"%s\",\n", field, yytext);
	printNTimes(profundidade, '\t');
	printf("%s", string);
}

void printFieldNum(char* field, long num, int ultimo){
	char string[yyleng+100];
	if (ultimo == 1) sprintf(string, "\"%s\": %ld\n", field, num);
	else sprintf(string, "\"%s\": %ld,\n", field, num);
	printNTimes(profundidade, '\t');
	printf("%s", string);	
}

void printTimestamp(){
	char string[25];
	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	//sprintf(string, "\"timestamp\":%d-%02d-%02d,\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
	sprintf(string, "\"timestamp\": %d,\n", t);
	printFieldStringPreDef(string);	
}

int main(int argc, char* argv[]){ 
	
	
	if(argc < 2){
		help();
		return 0;
	}
	

	if(access(argv[1], F_OK) != -1){

		if(access(argv[1], R_OK) != -1){
			char comm[200];
			
			/*
			int len = strlen(argv[1]);

			// definir nome do novo ficheiro
			char nome[len+3];
			strcpy(nome, argv[1]);
			nome[len-5] = '\0';
			strcat(nome, "JSON.json");
			*/

			// abrir o ficheiro a escrever
			
			// escrever nome da collection
			printf("\"commentThread\": [\n");
			
			// abrir o ficheiro a ler
			//sprintf(comm, "iconv -f cp1252 -t utf8 \"%s\"", argv[1]); 
			//yyin = popen(comm, "r"); 
			//yyin = NULL;

			yyin = fopen(argv[1], "r");

			// inicializar a leitura
			yylex();
	
			// fechar o ficheiro
			printf("]\n");

			fclose(yyin); 

			// falta fazer system para transformar a saída 

	
		}
		else{
			printf("Não possui permissão de leitura sobre o ficheiro fornecido!\n");
		}
	}
	else{
		printf("O ficheiro dado como argumento não existe !\n");
	}
	

	// Nivel r = testeInit();

	// printf("Número total de filhos de forma acumulativa: %ld\n", numberOfRepliesV1(r));

	return 0;
}
